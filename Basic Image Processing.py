# -*- coding: utf-8 -*-
"""COEfilePyCode.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bmp5QElawWPYJNBLIL6hZC-bpscDcPXl
"""

# ----------------------------------------------------------------------
# STEP 1: Colour image to Binary(B&W) image

import cv2

img = cv2.imread('500rs.png', 2)
ret, bw_img = cv2.threshold(img, 100, 255, cv2.THRESH_BINARY)
cv2.imwrite("BinIm.png", bw_img)

# ----------------------------------------------------------------------
#STEP 2: Cropping of an image

from PIL import Image # Importing Image class from PIL module

im = Image.open(r"BinIm.png") # Opens a image in RGB mode

width, height = im.size # Size of the image in pixels (size of original image)

# Setting the points for cropping the image
left = 662 - 10
top = 0
right = 685 + 10
bottom = height

im1 = im.crop((left, top, right, bottom)) # Cropped image of above dimension

im1.save(r"SecStrp.png") # Saves the image

# ----------------------------------------------------------------------
# STEP 3: Creating the array of B&W strip

import PIL
from PIL import Image # Importing Image from PIL package

# loading and creating the image object
im = PIL.Image.open("SecStrp.png")

# fetching the dimensions
wid, hgt = im.size

arr = []

# creating the array of the cropped binary image
for i in range(int(str(hgt))):
    arr_ins = []
    for j in range(int(str(wid))):
        arr_ins.append(0)
    arr.append(arr_ins)
for i in range(int(str(hgt))):
    for j in range(int(str(wid))):
        coordinate = x, y = j, i
        if im.getpixel(coordinate) == 255:
            arr[i][j] = 1
        else:
            arr[i][j] = 0

# ----------------------------------------------------------------------
#STEP 4: Counting the number of black pixels

l=[]
finalnote=[]
# number of black pixels per column
for i in range(int(str(wid))):
  k=0
  for j in range(int(str(hgt))):
    if arr[j][i]==0:
      k+=1
  l.append(k)

l2=[]

#number of black pixels per row
for j in range(int(str(hgt))):
  k=0
  for j in range(int(str(wid))):
    if arr[j][i]==0:
      k+=1
  l2.append(k)

# ----------------------------------------------------------------------
#STEP 5: Cropping the exact Security Strip and binary coding it

starti=0;

#final cropped Security Strip
#### For left right crop
for i in range(int(str(wid))):
  q=0
  for j in range(int(str(hgt))):
    if arr[j][i]==0:
      q+=1
    if q>=100:
      starti=i
      break
  if starti!=0:
    break

#### For top bottom crop
leftf = starti
topf = 0
rightf = starti+22
bottomf = height

imf = im.crop((leftf, topf, rightf, bottomf))  # Cropped image of above dimension

# Saves the image in image viewer
imf.save(r"FinalSec.png")

imgf = PIL.Image.open("FinalSec.png")

# fetching the dimensions of the cropped Security Strip
widf, hgtf = imgf.size
arrf=[]
for i in range(int(str(hgtf))):
    arrf_ins = []
    for j in range(int(str(widf))):
        arrf_ins.append(0)
    arrf.append(arrf_ins)
for i in range(int(str(hgtf))):
    for j in range(int(str(widf))):
        coordinate = x, y = j, i
        if imgf.getpixel(coordinate) == 255:
            arrf[i][j] = 1
        else:
            arrf[i][j] = 0

# ----------------------------------------------------------------------
# STEP 6: Saving the arrays in text files and then converting them into coe files

import numpy

numpy.savetxt("realtxt.txt", arrf,
              fmt='%i',
              delimiter=' ',
              newline='\n',
              header='',
              footer='',
              comments= '',
              encoding=None)

numpy.savetxt("realcoe.coe", arrf,
              fmt='%i',
              delimiter=',',
              newline='\n',
              header='',
              footer='',
              comments= '',
              encoding=None)

array_fake = numpy.loadtxt("fake.txt", dtype=int)

numpy.savetxt("fake.coe", array_fake,
              fmt='%i',
              delimiter=',',
              newline='\n',
              header='',
              footer='',
              comments= '',
              encoding=None)

arr_f2 = numpy.loadtxt("fake2.txt", dtype=int)

# ----------------------------------------------------------------------